В настройках левого и правого стика нужно добавить опцию  - добавлять параллельные события (на нужное направление стика влево вправо ввверх вниз) можно добавлять много событий, редактировать и удалять созданные события - например я в настройках правого стика, нажимаю на стрелочку влево к ней я могу добавить нажатие любой кнопки на джойстике - например кнопку крестик - теерь когда я дергаю правым стиком влево срабатывает стик с его настройками и дополнительно нажимается кнопка X . К этой кнопке - я могу добавить функции - как она будет работать





она сработает один раз пока стик не вернется в исходное положение



она сработает от 0.1  до 3 секунд - выведи шкалу для настройки



она будет зажата пока стик находится в левом положении  -



эти функции можно выбрать одну или сразу все, сделай так для каждтого стика для всех 4-х сторон у каждого стика. дай краткий ответ и подробнее где что добавить или заменить


не срабатывает по заданию, галочка постоянно висит на - Один раз пока не вернется , изменить и сохранить ничего не меняется . На правом стике этого меню нет, посмотри почему.не срабатывает по заданию, галочка постоянно висит на - Один раз пока не вернется , изменить и сохранить ничего не меняется . На правом стике этого меню нет, посмотри почему.




при редактировании не показывается направление - сделай так чтобы направление тоже можно редактировать, текст Зажата пока в положении - опусти ниже , он сейчас немного обрезан. Сохранения сохранятся теперь для каждого стика отдельно - это хорошо. Но на виртуьный джойстик данные присвоенные к сторонам стика все еще не отправляются

когда к направлениям стиков добавляешь дополнительную отправку кнопок, они не отправляются на виртуальный джойстик, посмотри почму, дай код короткий с точным описанием место что на что заменить добавить



когда к направлениям стиков добавляешь дополнительную отправку кнопок, они не отправляются на виртуальный джойстик, посмотри почму, дай код короткий с точным описанием место что на что заменить добавить Срабатывать отправление стиков должны сразу после внутренней мертвой зоны



когда я добавляю дополнительную кнопку отправки к стику и ставлю Задержка перед сработкой, то дополнительная привязанная кнопка перестает отправляться с задержкой, это нужно исправить, нужно сделать так чтобы кнопка отправлялась с задержкой, и стоит учитывать что эта кнопка после задержки должна появиться после установленного времени задержки, а после выполнить Один раз пока не вернется , Время или Зажата пока в положении, или все сразу - эти условия не меняй. Так же если я стик в сторону дернул кратковременно, и стик вернулся в 0 , то дополнительная кнопка все равно должна сработать.



джойстики PS4 PS5 определяются, выведи в левом верхнем углу зеленую подпись если подключится PS4 или PS5, Xbox закомментируй . Если PS4 PS5 не определился, PS4 PS5 подписи должны быть серыми. Так же можно подключать другие устройства рули, джойстики, клавиатуры. ЗА PS4 и PS5 выведи  - добавить устройство. При нажатии на которого (так же можно нажимать  на PS4 и PS5) для изменения или добавления кнопок,  так же в правом углу сделай профили, изначальный default. Пользователь может создавать и сохранять проaили, в каждом профиле он может добавлять изменять все устройства включая PS4 (DualShock)  PS5 (DualSense) . Профили можно добавлять изменять удалять (пользователь видит только название профилей). При добавлении изменении устройства - пользователь может добавлять (привязывать) удалять кнопки  в новом окне появляется точно такой же джойстик, к которому он может привязать отвязать кнопки стики, клавиатуру (все вместе). После как он привяжет новое устройство должно добавиться в список к PS4 PS5 с нужным названием.

Дай точечный код , с понятным описанием куда что добавить изменить.


не могу привязать дополнительное устройство,  кнопку привязать именно устройство размести рядом где выбор устройств.  Можно сделать чтобы в этот список не попадали виртуальные устройства? Чтобы они не повторялись в названии, и только те которые подключены?

напутана логика привязывания устройства, удали снизу : "Привязать" "Привязать" "Сохранить" которые снизу , когда пользователь выбирает устройство и нажимает Привязать устройство - оно должно сохраниться и отображаться после DualShok DualSense . Привязывание кнопок должно осуществляться, по нажатию название нового добавленного устройства, когда пользователь нажал на новое название, должен появиться джойстик, и в этом джойстике пользователь нажимает на любой элемет-кнопку и привязывает к этой кнопке кнопку из физического устройства. Так же нужно в список к каждому устройству добавить чекбокс какое устройство использовать или PS4 или PS5 (если серым - устройство не подключено то чекбокс тоже серый), можно ставить несколько чекбоксов, чтобы например использовать одновременно клавиатуру и джойстик
Указывай точно где что заменить добавить, без заглушек, мне не надо полный код файла только точечные изменения


15-11
если джойстики PS4 PS5 определяются, выведи в левом верхнем углу зеленую подпись если подключится PS4 или PS5. Если PS4 PS5 не определился ничего не выводи. Так же можно подключать другие устройства рули, джойстики, клавиатуры. ЗА PS4 или PS5 выведи (если они есть) там же в левом верхнем углу кнопку - добавить устройство. При нажатии на кнопку выводится окно, в нем: 1 список всех подключенных устройств ввода (подключенных и активных), 2 поле для ввода названия, 3 кнопку сохранять. Это устройство сохраняется перед кнопкой добавить стройство. Добавь нажатие на название устройства PS4 PS5 или на те которые добавились. При нажатии, должен появляться весь джойстик в новом окне, если кнопки имеют привязанность отправки на виртуальный джойстик обозначить их выдилением. При нажатии на любую нопку стик или триггер, можно задать им новую кнопку, можно на одну кнопку задать несколько кнопок, так же удалять привязанные кнопки. Когда кнопка или кнопки привязались можно сразу в этом окне их тестировать. Сохранение происходит сразу при добавлении или удалении кнопки. к кажжоу названию устройства должен приставлен быть чекбокс, который активный и это активное устройство должно отправлять данные на виртуальный джойстик. Важно не сломай существующую логику!!

Дай точечный код , с понятным описанием куда что добавить изменить. Я плохой программист так что дай код полный и с точным описанием от куда до куда вставить изменить


ошибок нет, но я не могу удалить устройства возле них нету кнопки удалить, так же Маппинг - Triggers и другие маппинги - это непонятно что, виртуальный джойстик отправляет PS4 PS5 кода, они правильные. Когда добавляется новое устройство, эти маппннги которые будешь приделывать к джойстику (который нарисован в программе) в новом устройстве, например стик триггер или другие кнопки отправляют то то и тото - если это клавиатура то стики все 4 направления задаются кнопками и эти кнопки с клавиатуры отправляют максимум, если это другой джойстик то пользователь выбирает на джойстике в программе направление например стик вверх он подсвечивается зеленым, пользователь дергает на физическом джойстике стик вверх и это действие запоминает эту команду и сохраняет. Физическое устройство подстраивается под виртуальный стик PS4 или PS5 отправку команды, ты меня понял? И сделай такчтобы пользователь мог выбирать только одно устройство, даже снимать галочку с PS4 ли PS5 .


я по прежнему не могу снять галочку с устройства, я должен галочку снимать с устройства если я снял галочку то это устройство не отправляет данные в виртуальный джойстик а виртуальный не отправляет в игру.  при нажатии на устройство добавленное джойстик визуальный не открывается, чтобы добавить изменить кнопки для отправки на виртуальный джойстик.


когда удаляю контроллер, сохранения не сбрасываются. Нужно чтобы к каждому устройству были свои сохранения, если устройство удаляется должны удаляться сохранения.  Нужно выводить только подключенные устройства и чтобы они не повторялись в списке, уточню проблема в повторяющихся устройств.  Где привязываются кнопки выведи окно для вывода логов. Я ничего не нажал, а захват уже выполнен. Привязывание кнопок с физического устройства мы прикрепляем аналогично как PS4 или PS5 отправляет на виртуальный. При прикреплении кнопки программа знает какой код-кнопки отправлять с виртуального джойстика в игру, но не знает кнопку физического контроллера, поэтому я думаю лучше иметь кодовую базу сразу (как на PS4 или PS5) и к этой базе прикреплять физические кнопки (может есть способ лучше, скажи мне об этом), так же пропадает кнопка "Добавить устройство" если контроллеры PS4 или PS5 не подключены. Я плохой программист выведи подробно где куда что вставить заменить, сделай минимальные изменения по заданию.
е меняю структуру, только корректирую логику в HandleAreaClick: для Joystick сохраняем симулированный raw byte (в реальности — из reader). Для Keyboard — как есть.


устройства по прежнему дублируются, как мне очищать PS4/ PS5 если его нельзя удалить? сделай чтобы его можно было удалить! и с удалением очищаются json настройки. окно логов прокрутка не спускается вниз. новое устройство например клавиатура не добавляются кнопки. новый джойстийк например тот же PS4 не могу изменить курки с левого на правый. хочу нажимать на левый курок, но чтобы отправлялся правый! дай краткий код, 
покажи от куда до куда что заменить вставить


Возможно, назначение-ссылка, допускающее значение NULL.

Допустимость значений NULL для ссылочных типов в типе параметра "sender" объекта "void AddDeviceForm.AddDeviceForm_Load_1(object sender, EventArgs e)" не соответствует целевому объекту делегирования "EventHandler" (возможно, из-за атрибутов допустимости значений NULL).

Допустимость значений NULL для ссылочных типов в типе параметра "sender" объекта "void DeviceMappingForm.DeviceMappingForm_Load_2(object sender, EventArgs e)" не соответствует целевому объекту делегирования "EventHandler" (возможно, из-за атрибутов допустимости значений NULL).

Полю "Form1.reader" нигде не присваивается значение, поэтому оно всегда будет иметь значение по умолчанию null.

Разыменование вероятной пустой ссылки.

Событие "Ds4Visualizer.TriggerAreaClicked" никогда не используется.

В программу добавляется сразу PS4 или PS5 не надо, пользователь сам должен добавить устройство. Пользователь при удалении устройства все его сохранения устройства должны удалиться.  При перезапуске программы, джойстик PS4 PS5 автоматически добавляться не должны. Если список добавленных устройств пуст, то файл settings.json должен быть пуст. Проследи что новое устройство при подключении в settings.json указывалось ID чтобы по этому ID сохраненные настройки удалялись при удалении устройства. Дай код кратко, и от куда до куда что вставить-заменить. сделай точечные изменения не ломая текущую логику.
я не могу удалить PS4/PS5 контроллер, так же он не должен автоматически добавляться при открытии программы, при PS4/PS5 контроллер удалении так же должны удаляться настройки




Привязывание и изменение кнопок физического устройства на виртуальном не работает! На виртуальном устройстве должна быть маппинг карта - работающая - она есть это карта PS4 и PS5 может сделай ее отдельную, чтобы проще было добавлять к этой карте новые устройства например рули джойстики клавиатуры, и если я хочу привязать к этой карте кнопки джойстики тригерры стики, я нажимаю на элемент виртуального джойстика появляется окно где идет 3 секунды чтобы привязать кнопку от устройства. Когда пользователь добавляет устройство PS4 или PS5 маппинг карта работающая уже добавляется сразу, но потом при нажатии на это устройство, кнопки можно было перезаписать изменить. Дай код кратко, и от куда до куда что вставить-заменить. сделай точечные изменения не ломая работующую логику.  Ты мне ебешь уже 5 часов мозг, не сокращай код!!!прошу не делай сокращений


После удаления PS4/PS5 контроллер - удаляется, но после закрытия и новой загрузки программы контроллер появлялся вновь PS4/PS5 контроллер с теми же сохраненными настройками в settings.json при удалении PS4/PS5  контроллер не должен появляться в программе. Пользователь сам его добавит.
К каждому добавленному устройству должны присваиваться свои настройки, при добавлении если PS4/PS5 контроллер то к ним прикрепляется существующие маппинг карты, если другое устройство то маппинг карта должна прикрепляться пустая.
существует два типа маппнг карт, постоянная - правильная, которая соответствует правильной карте X-Box виртуального контроллера - подскажи где находится маппинг карта эта. Второй тип маппинг карты это - маппинг карта устройства, она может быть сразу заполнена как в  PS4/PS5 контроллер или пустая - другие устройства.
при добавлении новых устройств - должны добавляться в сохранение settings.json свои настройки. Если галочки в добавленных устройствах сняты, то настройки менять нельзя, так как не понятно к какому устройству будут относиться изменения.
привяжи каждое устройство к своим настройкам, и если устройство удаляется то и удаляются настройки. Добавлять новое устройство можно , даже если PS4/PS5 контроллер не подключены или не добавлены или список устройств пуст.
дай абсолютно полные нужные файлы, без сокращений, чтобы я скопировал вставил и все заработало


не могу добавить новое устройство если контроллер PS4 / PS5 не подключен, сделай так чтобы новое устройство можно было подключать всегда . Так же сделай чтобы настройки можно было сохранять в файл (в папку с программой и дать название файлу) и загружать настройки из файла. Дай ответ кратко, уточни подробно, от куда до куда вставить заменить.


ты можешь сделать, чтобы виртуальный джойстик не отображался в списке добавляемых устройств? программа запускается, виртуальный джойстик создается, и его же можно добавить в программу? это не правильно. Так же когда я подключаю к программе джойстик xbox физический 360 он в списке добавляемых устройств не отображается

сделай нумерацию, когда пользователь добавляет устройство xbox (нажимает на кнопку) отключи виртуальный, чтобы пользователь знал что добавляет физический, как добавил физический включи сразу и виртуальный, и когда пользователь добавил физический, чтобы это устройство добавилось в список, где его можно потом удалить.


сделай нумерацию, когда пользователь добавляет устройство xbox (нажимает на кнопку) отключи виртуальный, чтобы пользователь знал что добавляет физический, как добавил физический включи сразу и виртуальный, и когда пользователь добавил физический, чтобы это устройство добавилось в список, где его можно потом удалить. (он добавляется но нужно перезапускать программу) пользователь может запустить программу, вставить джойстик, а потом пробывать подключить джойстик, поэтому когда пользователь пробует найти джойстик в кладке HID или xinput нужно обновлять устройства чтобы не перезапускать программу.

когда я подключаю джойстик от xbox в браузере https://mitinogame.ru/gamepad-tester/ тестер работает, а вот в программе нет, стики не двигаются. и значит не отправляют данные на виртуальный джойстик. Как сделать чтобы физический джойстик xbox реагировал на движения и отправлял данные на виртуальный джойстик

работа крестика лучше не стало, посмотри правильный гайд по крестику, стики левый и правый перепутаны вертикали, нажимаю на вверх опускается на низ, курки так же не работают


<TargetFramework>net9.0-windows10.0.19041.0</TargetFramework>
SharpDX.XInput
SharpDX.DirectInput
using Windows.Gaming.Input; - данные мы будем брать из системного API.

добавить 2  SharpDX.XInput и Windows.Gaming.Input + PS4


курки - триггеры отправляют данные на виртуальный джойстик но в программе не отображается нажатие, стики левый и правый правильно отправляют данные (перепутано вертикальность, нажимаю вниз стики в программе идут вверх, но данные отправляются правильно) но не правильно отображают в самой программе. когда будешь исправлять не сломай логику PS4 PS5 на xbox курки не настраиваются, а стики настраиваются. дай ответ точечный точно укажи где что вставить заменить


сделай XboxVisualizer дай его полный код, он будет похож на Ds4Visualizer только поменяй в нем вертикальность стиков , перепутана вертикальная инверсия у обоих стиков . когда пользователь выбирает xbox SharpDX.XInput  то должен подгружаться будет XboxVisualizer

Перестань передавать сырые byte в визуализатор
Передавай те же значения, которые идут в ViGEm (уже обработанные short)
чтобы визуализатор показывал те данные которые отправляет, чтобы это было актуально для PS4/PS5 и xbox

я подключил дешевый руль это не PS4 / PS5 не xbox - как сделать чтобы он работал в программе?


все работает но программа сама шлет данные именно крестовина d-pad в вверх. Когда подключаешь джойстик отправка вверх пропадает, но когда не подключено ни одно устройство или подключен руль, отправка кнопки вверх продолжается

https://remont-pristavok.by/test-gamepad

HidSharp
SharpDX.XInput
SharpDX.DirectInput
using Windows.Gaming.Input;
это основные сервисы для обнаружения геймпада и их кнопок для отправки на виртуальный джойстик?

#nullable disable

Я хочу в программе изменять кнопки например в руле, нажимаю на устройство появляется джойстик ,в джойстике почему то нажата сразу кнопка вверх d-pad up все остальные кнопки не визуализируются, нужно сделать так же визуализацию, не битовую, а по данным которые отправляются
как  только  хочу переблиндить элемент на другую кнопку он сразу производит захват, но я на физическом устройстве еще ничег оне нажимал.


у меня руль определяется как using SharpDX.DirectInput; почему то второй стик который справа в визуализаторе направлен веерх и вправо - и отправляет данные на виртуальный джойстик. посмотри почему, сам физический руль никаких данных не шлет.

нужно для ps4 ps5 sony оставалась такой же, для xbox контроллеров SharpDX.XInput оставить такой же, для все остальных рулей и других устройств  SharpDX.DirectInput
логика четко разделялась на Sony (HID), Xbox (XInput) и все остальные (DirectInput), достаточно внести два точечных изменения в проверку условий.


как в этом коде добавляются рули и другие устройства кроме PS4 PS5 Sony, и кроме xbox контроллеров?

в настройках триггеров нужно добавить замедление , нужна шкала (шкалу можно изменять мышкой) для каждого триггера пользователь выбирает в шкале (шкала - это полный ход триггера) с учетом выбора чувствительности
например пользователь берет вторую половину шкалы и устанавливает время от 0.01 до 0.5 и когда пользователь нажимает триггер с этого диапазона отправка (и визуализатор) отправляет данные с задержкой,
например он зажал полностью триггер - данные пошли отправляться с задержкой от 155 до 255 или до 210, но как пользователь отнял триггер - например с 210 до 209 (отправка данных с задержкой увеличением прекращается ) 
пример пользователь выбрал всю шкалу от 0 до 255 с задержкой  0.5 между каждым значением , он нажал сразу максимум 255, отправка пошла 1 (0.5 сек) 2 (0.5 сек) ... и так до 255
но если он нажал 255 и резко установил 155 то цикл сразу прерывается и программа сразу перестает слать данные с задержкой до 255, а отправляет 155, и если потом пользователь нажал опять 255, то если условие шкалы совпадает то начинает слать задержкой от 155 до 255
это делается для левого и правого триггера, левый тормоз - чтобы в игре не допустить блокировку колес, а правый триггер чтобы не допустить пробуксовку.
сделай это в одном методе private void SendToViGEm  чтобы не менять в трех местах XboxXInput , HID , directInputJoystick   я не программист укажи абсолютно точно чтобы ребенок понял где что изменить добавить, SettingsForm дай полностью

DateTime.Now в Windows имеет реальное разрешение ≈ 10–15 мс (на большинстве систем)
Даже если ты поставишь задержку 0.001 сек (1 мс), проверка (now - start).TotalSeconds >= delay будет срабатывать только каждые ~10–16 мс.
Thread.Sleep(1) в цикле чтения контроллера
Минимальная «честная» пауза в Windows — около 15 мс. Sleep(1) часто превращается в 15–16 мс.
NumericUpDown (или другой контрол в UI) обычно имеет шаг 0.01 или 0.1 секунды
Пользователь физически не может выставить 0.001 с удобством, если шаг не уменьшен.
Цикл обработки триггеров происходит не чаще, чем приходит отчёт от контроллера
DualShock 4 / DualSense обычно шлют данные ~250–1000 Гц (1–4 мс), но из-за Sleep(1) + DateTime + обработка ты получаешь реальную частоту обновления ~60–100 Гц (10–16 мс).


максимальный диапазон регулируется на каждом стике каждую ось, нужно поставить галочку под каждой регулировкой Макс. диапазон X  Макс. диапазон Y в каждом стике, при установке пользователем этого чекбокса диапазон стика уменьшается но отправляет все данные, при зажатой галочке ход стика будет уменьшен но в этот ход он будет отправлять все данные. дай подробное описание как ребенку где что изменить добавить напиши код полностью для обоих стиков.

"Включить вычитание L2 из R2 (тормоз ослабляет газ)" нужно в настройках триггеров добавить  "Включить вычитание R2 из L2 (тормоз ослабляет газ)"
чекбокс мог выбрать только одно , так же добавь логику чтобы  R2 из L2 так же работал

есть проблема с рулём SharpDX.DirectInput когда подключается, то педали не могут правильно работать, потому что назначается на одну левого стика , левая педаль ось y вниз  , правая педаль ось y вверх и они друг у друга отнимаю, а должны быть независимыми, что посоветуешь сделать?

я не понимаю, покажи блок который нужно заменить от а до б и я тебе сказал какая ось сейчас чем ты блядь слушаешь, ось руля это левый стик ось x ,  педали левый стик ось y , нужно педали перенести на триггеры

combined-режиме

в программе можно поставить галочку один виртуальный контролер? сейчас когда устройство добавляешь в список создается к каждому устройству виртуальное устройство, сделай галочку одно виртуальное устройство от всех устройств, если галочка стоит то от всех устройств идет к одному виртуальному устройству, если не стоит то у каждого устройство свое виртуальное устройств



в настройках левого и правого стика нужно добавить по два чекбоксу с логикой
"Force maximum range (растянуть данные в диапазоне)" X
"Force maximum range X (всегда отправлять максимум в пределах диапазона)",
"Force maximum range (растянуть данные в диапазоне)" Y
"Force maximum range Y (всегда отправлять максимум в пределах диапазона)",
под каждым этим чекбоксом нужно поставить по одному чекбоксу , выбрать два сразу нельзя, логика выборать один из двух или оба пустые
когда например выбираешь чекбокс Force maximum range X то стик отправляет максимум из Макс. диапазон по X
дай точечный ответ, для обоих стиков, покажи точно что где изменить


настройка триггеров левого и правого - Замедление нарастания триггеров (только при увеличении)
нужно добавить:  настройка триггеров левого и правого - Замедление уменьшения триггеров (только при уменьшении)
сделай точно такую же логику но на уменьшение и чтобы они работали вместе, как одно целое, дай точечный ответ где что заменить ставить

настройка триггеров левого и правого - Замедление нарастания триггеров (только при увеличении)
при настройке левого и правого триггера используется две шкалы Start End, нужно сделать одну шкалу для левого и правого триггера и чтобы Start не заходил за End, а End не заходил за Start  дай самые короткие изменения, только UI логику 
так же нужно добавить:  настройка триггеров левого и правого - Замедление уменьшения триггеров (только при уменьшении)
сделай точно такую же логику но на уменьшение и чтобы они работали вместе, как одно целое, дай точечный ответ где что заменить ставить



Замедление нарастания триггеров (только при увеличении) и Замедление уменьшение триггеров (только при уменьшении)



для всех
HidSharp
SharpDX.XInput
SharpDX.DirectInput
устройства отправляют данные через один единственный виртуальный джойстик, сейчас идет конфликт устройства отсылают данные даже в нейтральном положении
если на устройствах элементы в начальном положении то не нужно слать данные если кнопки на устройствах не нажаты (то слать их не нужно что они не нажаты, когда пользователь отпускает кнопку
отослать данные )
 (для триггеров это касается только 0, а стиков начального положения с учетом мертвых зон LeftStickSettingsForm.cs RightStickSettingsForm.cs ).
каждой кнопки каждого стика и триггера на всех добавленных устройствах
можно это сделать с минимальными изменениями в ControllerReader.cs не создавая лишнего в Form1 ? 
как будет с отправкой дрожания стиков? - ведь у них есть дрожание, можно регулировать начальную отправку стиков через
LeftStickSettingsForm.cs
RightStickSettingsForm.cs 
там есть настройка мертвой зоны
дай точечные изменения, где что изменить добавить.



в настройку стиков (Event Settings) нужно добавить выбор левый и правый триггер, 4 направления (вверх , вниз, влево, вправо) левого стика, 4 направления (вверх , вниз, влево, вправо) правого стика стика, когда пользователь выбирает триггеры или направление стиков у него в опции должно дополнительно появиться - чувствительность нажатия - выведи шкалу - чтобы мышкой можно было выбрать чувствительность.  чтобы можно для триггеров и стиков выбрать все функции в форме Event Settings + дополнительно выбрать чувствительность. Дай точечный ответ, от куда до куда изменить код.
в Event Settings (то есть именно в диалоге StickEventDialog) видеть выбор триггеров и направлений стиков прямо внутри окна, а не снаружи в родительских формах. Дай минимальные изменения, указывай точно лучше целыми блоками от куда до куда изменить


нужно реализовать логику с отдельным классом
добавить на главную форму Form1 кнопку SETTINGS, при нажатии появляется новое окно
в новом окне поля, чекбоксы и лист с настройками: 
1) первое выбрать любой элемент джойстика: кнопку, триггер или любое направление из четырех левого и правого стика. Это все кнопки, два триггера и 4 + 4 направления каждого стика
если пользователь выбирает триггер или стик у него должно появиться дополнительно чувствительность при которой сработает действие для элемента второго поля.

2) второе поле - что будет срабатывать, так же все элементы что и в первом поле, даже пользователь может выбрать там и там одно направление стика например, чтобы улучшить управление и настройки
дальше поведение кнопок во втором поле.
настройки 3 чекбокса выбрать можно только один: 
1 чекбокс "Held while in position" - когда элемент первого поля нажат (а триггеры и стики учитывают еще чувствительность)
2 чекбокс "Timed (0.1-3sec)" срабатывает на время после того как элемент первого поля активизировался (а триггеры и стики учитывают еще чувствительность)
3 чекбокс "Delay after release (0.1-3sec)" если пользователь отпустил кнопку или триггеры-стики по чувствительности
шкалу (0.1-3sec) временную от 0.1 до 3 секунд, (можно перемещать ползунок мышкой) (когда установлен "Held while in position" шкала выключена, для Timed (0.1-3sec) и Delay after shutdown (0.1-3sec) включена)

4 чекбокс "Delay before trigger" сработка с задержкой и к нему шкала от 0.05 до 2 секунд задержка сработки (можно перемещать ползунок мышкой) работает только с Timed (0.1-3sec) и Delay after shutdown (0.1-3sec) (если выбран "Held while in position" то "Delay before trigger" выключен)

Если пользователь выбрал во втором поле триггер или направление стика то должна появляться еще одна шкала - чувствительности (для триггера и направления стика)
для триггера я так понимаю 0-255 для направления стика 0-90 - выведи сразу под вторым полем, где выбирются элементы которые будут срабатывать.

кнопка сохранить
под кнопкой список добавленных настроек
при нажатии на каждую добавленную настройку можно ее удалить, редактировать, отключать (чекбоксом)
поле редактирование сделай сам. 
много уже реализовано в Event Settings StickEventDialog - сделай аналогию с добавлением по заданию.


***
когда выбираешь Input element кнопку (не триггер и не стик) то шкалы не должно быть  когда выбираешь Output element кнопку (не триггер и не стик) так же шкалы не должно быть
когда выбираешь стик то шкала должна быть 0 - 90 (90 это максимум - в направлении стика максимум это 90?) , когда выбираешь триггер деления должно быть 0 - 255 , когда выбран Held while in position  шкала  Delay before trigger должна быть не активной


маппинг копок ABXY работает, стики и триггеры не работает маппинг, крестовина вверх вниз влево вправо вообще не работает на виртуальном джойстике, и естественно маппинг крестовины не работает. логи триггера маппинга на стик private void SendToViGEm(short lx, short ly, short rx, short ry, byte l2, byte r2, byte b1, byte b2, byte b3) {     if (device != null && device.VendorID != 0x054C && LatestDpad == 0)     {         LatestDpad = 8;     }

    if (virtualPad == null)     {         SafeLog("SendToViGEm: virtualPad is null — выходим", Color.Red);         return;     }

    bool isDS5 = isDualSense || lastReportId == 0x31;

    buttonContributions.Clear();

    // Сначала маппинги (приоритет)     try     {         ProcessActionMappings(virtualPad, buttonContributions, lx, ly, rx, ry, l2, r2);     }     catch (Exception ex)     {         SafeLog($"ERROR in ProcessActionMappings: {ex.Message}", Color.Red);     }

    // Затем физические кнопки (OR с маппингами)     if (isDS5)     {         buttonContributions[Xbox360Button.X] = (b1 & 0x10) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.X, false);         buttonContributions[Xbox360Button.A] = (b1 & 0x20) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.A, false);         buttonContributions[Xbox360Button.B] = (b1 & 0x40) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.B, false);         buttonContributions[Xbox360Button.Y] = (b1 & 0x80) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.Y, false);     }     else     {         buttonContributions[Xbox360Button.A] = (b1 & 0x20) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.A, false);         buttonContributions[Xbox360Button.B] = (b1 & 0x40) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.B, false);         buttonContributions[Xbox360Button.X] = (b1 & 0x10) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.X, false);         buttonContributions[Xbox360Button.Y] = (b1 & 0x80) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.Y, false);     }

    buttonContributions[Xbox360Button.LeftShoulder] = (b2 & 0x01) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.LeftShoulder, false);     buttonContributions[Xbox360Button.RightShoulder] = (b2 & 0x02) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.RightShoulder, false);     buttonContributions[Xbox360Button.Back] = (b2 & 0x10) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.Back, false);     buttonContributions[Xbox360Button.Start] = (b2 & 0x20) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.Start, false);     buttonContributions[Xbox360Button.LeftThumb] = (b2 & 0x40) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.LeftThumb, false);     buttonContributions[Xbox360Button.RightThumb] = (b2 & 0x80) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.RightThumb, false);     buttonContributions[Xbox360Button.Guide] = (b3 & 0x01) != 0 || buttonContributions.GetValueOrDefault(Xbox360Button.Guide, false);

    byte dpadRaw = LatestDpad;     buttonContributions[Xbox360Button.Up]    = (dpadRaw == 0 || dpadRaw == 1 || dpadRaw == 7) || buttonContributions.GetValueOrDefault(Xbox360Button.Up, false);     buttonContributions[Xbox360Button.Down]  = (dpadRaw == 4 || dpadRaw == 3 || dpadRaw == 5) || buttonContributions.GetValueOrDefault(Xbox360Button.Down, false);     buttonContributions[Xbox360Button.Left]  = (dpadRaw == 6 || dpadRaw == 5 || dpadRaw == 7) || buttonContributions.GetValueOrDefault(Xbox360Button.Left, false);     buttonContributions[Xbox360Button.Right] = (dpadRaw == 2 || dpadRaw == 1 || dpadRaw == 3) || buttonContributions.GetValueOrDefault(Xbox360Button.Right, false);

    // Лог только если хоть одна кнопка изменилась по сравнению с предыдущим вызовом     bool anyChange = false;     foreach (var kv in buttonContributions)     {         if (kv.Value) anyChange = true;     }

    if (anyChange)     {         SafeLog($"[BTN FINAL] Button states before SubmitReport:", Color.White);         foreach (var kv in buttonContributions)         {             if (kv.Value)                 SafeLog($"  → {kv.Key}: PRESSED", Color.Lime);         }     }

    // Отправка     foreach (var kv in buttonContributions)     {         virtualPad.SetButtonState(kv.Key, kv.Value);     }

    virtualPad.SetAxisValue(Xbox360Axis.LeftThumbX, leftX);     virtualPad.SetAxisValue(Xbox360Axis.LeftThumbY, leftY);     virtualPad.SetAxisValue(Xbox360Axis.RightThumbX, rightX);     virtualPad.SetAxisValue(Xbox360Axis.RightThumbY, rightY);

    virtualPad.SetSliderValue(Xbox360Slider.LeftTrigger, l2);     virtualPad.SetSliderValue(Xbox360Slider.RightTrigger, r2);

    virtualPad.SubmitReport(); }   дай точечные изменения



нужно полностью убрать в левом и правом стике в настройках Direction, удалить StickEventDialog и удалить все что с ним связывает в других полях в ControllerReader


у меня проблема с маппингом направлений стиков (не осей, не перепутай), я не могу задать кнопе направление стика, а направлению стика могу задать кнопку. Стик  должен идти по направлению до определенного порога - посмотри где что не учитывается. Посмотри в чем причина, дай точечный ответ.



1 в настройках маппинга "Timed (0.1-3sec)" и "Delay after release (0.1-3sec)" не работает правильно. "Timed (0.1-3sec)" и при включенном "Delay before trigger 0.05 - 2 sec" не срабатывает отсрочка включения, при этих двух чекбоксах Timed (0.1-3sec)" должен включиться по задержке  "Delay before trigger 0.05 - 2 sec"
2 "Delay after release (0.1-3sec)" должен сработать на "Timed (0.1-3sec)" после как Input element вернется в первоначальное положение или для направления стиков и триггеров за первоначальную чувствительность (сейчас он срабатывает сразу по Input element)
3 "Delay after release (0.1-3sec)" и "Delay before trigger 0.05 - 2 sec" должен сработать после того как Input element вернется и пройдет 


при двух активных чекбоксах "Delay after release (0.1-3sec)" и "Delay before trigger 0.05 - 2 sec" Outputelement должен сработать после того как Input element вернется и пройдет "Delay before trigger 0.05


 можешь  к Input element добавить чекбокс и шкалу, если чекбокс включен то сработка пойдет тогда когда еще и input будет активирован определенное время - добавить эту логику не изменяя существующей. диапазон от 0.05 до 2 секунд

так же у меня происходит конфликт когда я назначаю на выход триггер, тригеер отсылает на виртуальный джойстик дефолтное значение, а маппинг свой, нужно сделать если маппинг отсылает значение на триггер то дефолтное от джойстика не шлем, когда маппинг перестает слать тогда и физический дефолтный джойстик может слать

идет конфликт триггеров с маппингом, когда я привязываю на кнопку триггер и ему значение 255 и нажима на кнопку то триггер конфликтует 255-0-255-0  у стиков этой проблемы нет, там идет отправка в первую очередь маппинга, сделай так же и с триггером, дай точечные изменения


